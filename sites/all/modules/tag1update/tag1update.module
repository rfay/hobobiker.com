<?php

/**
 * @file
 * Reports on installed Drupal 6 modules and themes to Tag1 Consulting, in
 * order to receive security updates. This is part of a paid Drupal 6 Long Term
 * Support service.
 */

/**
 * URL to check for updates.
 */
define('TAG1UPDATE_DEFAULT_URL', 'https://updates.tag1consulting.com/entity/d6lts_site');

/**
 * Report changes roughly once every hour. (1 hour minus ten minues)
 */
define('TAG1UPDATE_REPORT_CHANGE_FREQUENCY', 3000);

/**
 * Report lack of changes roughly once every day. (1 day minus ten minutes)
 */
define('TAG1UPDATE_REPORT_NOCHANGE_FREQUENCY', 85800);

/**
 * Implementation of hook_help().
 */
function tag1update_help($path) {
  switch ($path) {
    case 'admin/help#tag1update':
      return '<p>' . t('Reports on your installed Drupal 6 modules and themes to Tag1 Consulting so they can provide security updates backported from Drupal 7 and Drupal 8. This is part of a paid Drupal 6 Long Term Support service.') . '</p>';
  }
}

/**
 * Implenentation of hook_perm().
 */
function tag1update_perm() {
  return array('administer tag1update');
}

/**
 * Implementation of hook_menu().
 */
function tag1update_menu() {
  $items = array();

  $items['admin/settings/tag1updates'] = array(
    'title' => 'Tag1 Consulting Drupal 6 updates',
    'description' => 'Configure your website to talk to the Tag1 Consulting update server for Drupal 6 Long Term Support.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tag1update_admin_settings'),
    'access arguments' => array('administer tag1update'),
    'file' => 'tag1update.admin.inc',
  );
  $items['admin/settings/tag1updates/configuration'] = array(
    'title' => 'Configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tag1update_admin_settings'),
    'access arguments' => array('administer tag1update'),
    'file' => 'tag1update.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  $items['admin/settings/tag1updates/review'] = array(
    'title' => 'Review',
    'description' => 'Review the information this module is sending to Tag1 Consulting.',
    'page callback' => 'tag1update_admin_review',
    'access arguments' => array('administer tag1update'),
    'file' => 'tag1update.admin.inc',
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/settings/tag1updates/status'] = array(
    'title' => 'Status',
    'description' => 'Status of information being sent to Tag1 Consulting.',
    'page callback' => 'tag1update_admin_status',
    'access arguments' => array('administer tag1update'),
    'file' => 'tag1update.admin.inc',
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/settings/tag1updates/status/manual'] = array(
    'title' => 'Manually send',
    'description' => 'Manually send report to Tag1 Consulting.',
    'page callback' => 'tag1update_admin_send_manually',
    'access arguments' => array('administer tag1update'),
    'file' => 'tag1update.admin.inc',
    'type' => MENU_CALLBACK
  );

  return $items;
}


/**
 * Implementation of hook_cron().
 */
function tag1update_cron() {
  tag1update_update_status();
  $next_update = tag1update_next_update();
  if ($next_update <= 0) {
    tag1update_send_report();
  }
}

/**
 * Collect details about enabled themes and modules.
 */
function tag1update_update_status() {
  if (variable_get('tag1update_report', 1)) {
    // Build an array of all currently enabled modules.
    $current = array();
    $modules = module_rebuild_cache();
    foreach ($modules as $name => $module) {
      // We only care about enabled modules.
      if ($module->status == 1) {
        $current["$module->type:$module->name"] = array(
          'name' => $module->name,
          'type' => $module->type,
          'info_name' => $module->info['name'],
          'info_package' => $module->info['package'],
          'info_version' => $module->info['version'],
          'schema_version' => $module->schema_version,
        );
      }
    }

    // Add to the array all currently enabled themes.
    $themes = list_themes();
    foreach ($themes as $name => $theme) {
      // We only caer about enabled themes.
      if ($theme->status == 1) {
        $current["$theme->type:$theme->name"] = array(
          'name' => $theme->name,
          'type' => $theme->type,
          'info_name' => $theme->info['name'],
          'info_package' => $theme->info['engine'],
          'info_version' => $theme->info['version'],
          'schema_version' => $theme->schema_version,
        );
      }
    }

    // Retrieve array describing all previously installed projects.
    $old = array();
    $result = db_query('SELECT name, type, info_name, info_package, info_version, schema_version FROM {tag1update}');
    while ($project = db_fetch_array($result)) {
      $type = $project['type'];
      $name = $project['name'];
      $old["$type:$name"] = $project;
    }

    $update = FALSE;
    // See if anything else has changed.
    foreach ($current as $key => $value) {
      if (!isset($old["$key"])) {
        // Something new has been enabled.
        $update = TRUE;
        db_query("INSERT INTO {tag1update} (name, type, info_name, info_package, info_version, schema_version) VALUES('%s', '%s', '%s', '%s', '%s', '%s')", $value['name'], $value['type'], $value['info_name'], $value['info_package'], $value['info_version'], $value['schema_version']);
      }
      else if ($value['info_version'] != $old["$key"]['info_version'] ||
               $value['schema_version'] != $old["$key"]['schema_version']) {
        // Something has changed.
        $update = TRUE;
        db_query("UPDATE {tag1update} SET info_name = '%s', info_package = '%s', info_version = '%s', schema_version = '%s' WHERE name = '%s' AND type = '%s'", $value['info_name'], $value['info_package'], $value['info_version'], $value['schema_version'], $value['name'], $value['type']);
        unset($old["$key"]);
      }
      else {
        // Nothing has changed.
        unset($old["$key"]);
      }
    }
    // Anything left has been disabled, remove.
    foreach ($old as $key => $value) {
      db_query("DELETE FROM {tag1update} WHERE name = '%s' AND type = '%s'", $value['name'], $value['type']);
    }
    if (!empty($old) || $update) {
      if (!variable_get('tag1update_update', FALSE)) {
        variable_set('tag1update_update', TRUE);
      }
    }
  }
  else {
    // Be sure we're not collecting information when disabled.
    db_query('DELETE FROM {tag1update}');
  }
}

/**
 * Return an array of all tracked data.
 */
function tag1update_get_status() {
  global $base_url;

  $status = array(
    'type' => array(array('target_id' => 'd6lts_site')),
    'title' => array(array('value' => variable_get('site_name', 'Drupal'))),
    'field_site_identifier' => array(array('value' => tag1update_get_site_identifier())),
    'field_base_url' => array(array('value' => $base_url)),
    'field_server_name' => array(array('value' => check_plain($_SERVER['SERVER_NAME']))),
    'field_server_address' => array(array('value' => check_plain($_SERVER['SERVER_ADDR']))),
    'field_php_self' => array(array('value' => check_plain($_SERVER['PHP_SELF']))),
    'field_php_version' => array(array('value' => phpversion())),
    'field_last_update' => array(array('value' => time())),
    'field_enable_timestamp' => array(array('value' => tag1update_get_enable_timestamp())),
  );
  $field_json_data = array();
  $result = db_query('SELECT * FROM {tag1update}');
  while ($update = db_fetch_array($result)) {
    $field_json_data[] = $update;
  }
  $status['field_json_data'] = array(array('value' => $field_json_data));
  return $status;
}

/**
 * Return a unique site identifier.
 */
function tag1update_get_site_identifier() {
  $tag1update_siteid = variable_get('tag1update_siteid', NULL);

  if (is_null($tag1update_siteid)) {
    $tag1update_siteid = hash('sha256', mt_rand() . tag1update_get_enable_timestamp());
    variable_set('tag1update_siteid', $tag1update_siteid);
  }

  return $tag1update_siteid;
}

/**
 * Return a UNIX timestamp of when this module was enabled.
 */
function tag1update_get_enable_timestamp() {
  $tag1update_enable_timestamp = variable_get('tag1update_enable_timestamp', NULL);

  if (is_null($tag1update_enable_timestamp)) {
    $tag1update_enable_timestamp = time();
    variable_set('tag1update_enable_timestamp', $tag1update_enable_timestamp);
  }

  return $tag1update_enable_timestamp;
}

/**
 * Calculate the next time an update will be sent to Tag1.
 */
function tag1update_next_update() {
  $last_update = variable_get('tag1update_last_update', 0);
  if ($last_update == 0) {
    // No updates reported yet, report immediately.
    return 0;
  }

  $time_since_last_update = time() - $last_update;

  if (variable_get('tag1update_update', FALSE)) {
    if ($time_since_last_update > TAG1UPDATE_REPORT_CHANGE_FREQUENCY) {
      // We haven't reported in the last frequency, report immediately.
      return 0;
    }
    else {
      // We've reported recently, wait.
      return TAG1UPDATE_REPORT_CHANGE_FREQUENCY - $time_since_last_update;
    }
  }
  else {
    if ($time_since_last_update > TAG1UPDATE_REPORT_NOCHANGE_FREQUENCY) {
      // We haven't reported in the last frequency, report immediately.
      return 0;
    }
    else {
      // We've reported recently, wait.
      return TAG1UPDATE_REPORT_NOCHANGE_FREQUENCY - $time_since_last_update;
    }
  }
}

/**
 * Send a status report to Tag1 Consulting about installed modules.
 */
function tag1update_send_report() {
  $url = '';

  // The lock framework was added in Drupal 6.16 -- while Tag1 doesn't support
  // such outdated versions of core, for now just skip locking and report.
  // For recent versions of Drupal, prevent multiple threads from sending an
  // update at the same time.
  if (!function_exists('lock_acquire') || lock_acquire('tag1update_send_report', 60)) {
    $url = variable_get('tag1update_url', TAG1UPDATE_DEFAULT_URL);
    $status = tag1update_get_status();
    // Encode json_data
    $status['field_json_data'] = array(array('value' => tag1update_json_encode_helper($status['field_json_data'][0]['value'])));


    $headers = array(
      'Content-Type' => 'application/json',
      'Drupal-Auth-Token' => variable_get('tag1update_token', ''),
    );
    $result = drupal_http_request($url, $headers, 'POST', tag1update_json_encode_helper($status));

    if (isset($result->code) && $result->code >= 200 && $result->code < 300) {
      $result->success = TRUE;
      watchdog('tag1update', t('Successfully sent data to %url', array('%url' => $url)), array(), WATCHDOG_INFO);
    }
    else {
      $result->success = FALSE;
      watchdog('tag1update', t('Failed to send data to %url', array('%url' => $url)), array(), WATCHDOG_INFO);
    }

    if ($result->success == FALSE || variable_get('tag1update_debug', FALSE)) {
      if (!isset($result->code) || $result->code == 0) {
        // We're making an assumption here, but this has been the issue every
        // time we've run into this so far.
        watchdog('tag1update', 'fsockopen(): Failed to enable crypto in drupal_http_request(). Please verify that PHP was built with OpenSSL support, is properly configured, and isn\'t blocked by a firewall.', WATCHDOG_ERROR);
      }
      else {
        watchdog('tag1update', 'HTTP Response Code %code: %message', array('%code' => isset($result->code) ? $result->code : 0, '%message' => empty($result->error) ? $result->status_message : $result->error), $result->success ? WATCHDOG_NOTICE : WATCHDOG_ERROR);
      }
      if (isset($result->status_message)) {
        watchdog('tag1update', 'Message: %message', array('%message' => $result->status_message));
      }
      if (isset($result->data)) {
        watchdog('tag1update', 'Data: %data', array('%data' => $result->data));
      }
      if (isset($result->request)) {
        watchdog('tag1update', 'Request: %request', array('%request' => $result->request), WATCHDOG_DEBUG);
      }
      if (is_array($result->headers)) {
        $headers = array();
        foreach ($result->headers as $header => $value) {
          $headers[] = "$header: $value";
        }
        watchdog('tag1update', 'Response headers: %headers', array('%headers' => implode(' | ', $headers)), WATCHDOG_DEBUG);
      }
    }
    else {
      $result->success = TRUE;
    }

    if ($result->success) {
      // We've reported all changes.
      variable_del('tag1update_update');
      variable_set('tag1update_last_update', time());
    }
    else {
      watchdog('tag1update', t('Failed to send D6 LTS update to Tag1 Consulting.'));
    }
    if (function_exists('lock_release')) {
      lock_release('tag1update_send_report');
    }
  }

  return $result;
}

/**
 * Borrowed from Drupal 7, as drupal_to_js from Drupal 6 doesn't properly
 * encode all characters.
 * https://api.drupal.org/api/drupal/includes%21common.inc/function/drupal_json_encode/7
 */
function tag1update_json_encode($var) {
  // The PHP version cannot change within a request.
  static $php530;

  if (!isset($php530)) {
    $php530 = version_compare(PHP_VERSION, '5.3.0', '>=');
  }

  if ($php530) {
    // Encode <, >, ', &, and " using the json_encode() options parameter.
    return json_encode($var, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT);
  }

  // json_encode() escapes <, >, ', &, and " using its options parameter, but
  // does not support this parameter prior to PHP 5.3.0.  Use a helper instead.
  return tag1update_json_encode_helper($var);
}


/**
 * Borrowed from Drupal 7:
 * https://api.drupal.org/api/drupal/includes%21json-encode.inc/function/drupal_json_encode_helper/7
 */
function tag1update_json_encode_helper($var) {
  switch (gettype($var)) {
    case 'boolean':
      return $var ? 'true' : 'false'; // Lowercase necessary!

    case 'integer':
    case 'double':
      return $var;

    case 'resource':
    case 'string':
      // Always use Unicode escape sequences (\u0022) over JSON escape
      // sequences (\") to prevent browsers interpreting these as
      // special characters.
      $replace_pairs = array(
        // ", \ and U+0000 - U+001F must be escaped according to RFC 4627.
        '\\' => '\u005C',
        '"' => '\u0022',
        "\x00" => '\u0000',
        "\x01" => '\u0001',
        "\x02" => '\u0002',
        "\x03" => '\u0003',
        "\x04" => '\u0004',
        "\x05" => '\u0005',
        "\x06" => '\u0006',
        "\x07" => '\u0007',
        "\x08" => '\u0008',
        "\x09" => '\u0009',
        "\x0a" => '\u000A',
        "\x0b" => '\u000B',
        "\x0c" => '\u000C',
        "\x0d" => '\u000D',
        "\x0e" => '\u000E',
        "\x0f" => '\u000F',
        "\x10" => '\u0010',
        "\x11" => '\u0011',
        "\x12" => '\u0012',
        "\x13" => '\u0013',
        "\x14" => '\u0014',
        "\x15" => '\u0015',
        "\x16" => '\u0016',
        "\x17" => '\u0017',
        "\x18" => '\u0018',
        "\x19" => '\u0019',
        "\x1a" => '\u001A',
        "\x1b" => '\u001B',
        "\x1c" => '\u001C',
        "\x1d" => '\u001D',
        "\x1e" => '\u001E',
        "\x1f" => '\u001F',
        // Prevent browsers from interpreting these as as special.
        "'" => '\u0027',
        '<' => '\u003C',
        '>' => '\u003E',
        '&' => '\u0026',
        // Prevent browsers from interpreting the solidus as special and
        // non-compliant JSON parsers from interpreting // as a comment.
        '/' => '\u002F',
        // While these are allowed unescaped according to ECMA-262, section
        // 15.12.2, they cause problems in some JSON parsers.
        "\xe2\x80\xa8" => '\u2028', // U+2028, Line Separator.
        "\xe2\x80\xa9" => '\u2029', // U+2029, Paragraph Separator.
      );

      return '"' . strtr($var, $replace_pairs) . '"';

    case 'array':
      // Arrays in JSON can't be associative. If the array is empty or if it
      // has sequential whole number keys starting with 0, it's not associative
      // so we can go ahead and convert it as an array.
      if (empty($var) || array_keys($var) === range(0, sizeof($var) - 1)) {
        $output = array();
        foreach ($var as $v) {
          $output[] = tag1update_json_encode($v);
        }
        return '[ ' . implode(', ', $output) . ' ]';
      }
      // Otherwise, fall through to convert the array as an object.

    case 'object':
      $output = array();
      foreach ($var as $k => $v) {
        $output[] = tag1update_json_encode(strval($k)) . ':' . tag1update_json_encode($v);
      }
      return '{' . implode(', ', $output) . '}';

    default:
      return 'null';
  }
}
